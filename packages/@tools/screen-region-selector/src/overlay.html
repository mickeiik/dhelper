<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <title>Screen Region Selector</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: transparent;
            cursor: crosshair;
            overflow: hidden;
            user-select: none;
        }

        canvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }

        .instructions {
            position: fixed;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 15px;
            border-radius: 8px;
            font-family: system-ui, -apple-system, sans-serif;
            font-size: 14px;
            z-index: 1000;
            pointer-events: none;
        }

        .coordinates {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 10px;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            z-index: 1000;
            pointer-events: none;
        }
    </style>
</head>

<body>
    <div class="instructions">
        <div id="mode-instructions">Loading...</div>
        <div style="margin-top: 8px; font-size: 12px; opacity: 0.8;">
            ESC: Cancel | Enter: Confirm (rectangle mode)
        </div>
    </div>

    <div class="coordinates" id="coordinates">
        Mouse: (0, 0)
    </div>

    <canvas id="overlay-canvas"></canvas>

    <script>
        const { ipcRenderer } = require('electron');

        class ScreenRegionSelector {
            constructor() {
                this.canvas = document.getElementById('overlay-canvas');
                this.ctx = this.canvas.getContext('2d');
                this.mode = 'point';
                this.isSelecting = false;
                this.startX = 0;
                this.startY = 0;
                this.currentX = 0;
                this.currentY = 0;
                this.selection = null;

                this.setupCanvas();
                this.setupEventListeners();
                this.startRenderLoop();
            }

            startRenderLoop() {
                const loop = () => {
                    this.clearCanvas();
                    if (this.mode === 'rectangle' && this.isSelecting) {
                        this.drawSelection();
                    } else {
                        this.drawCrosshairs();
                    }
                    requestAnimationFrame(loop);
                };
                requestAnimationFrame(loop);
            }

            setupCanvas() {
                // Set canvas size to window size
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;

                // Set drawing styles
                this.ctx.strokeStyle = '#00ff00';
                this.ctx.lineWidth = 2;
                this.ctx.setLineDash([5, 5]);
            }

            setupEventListeners() {
                // Mouse events
                window.addEventListener('mousemove', (e) => this.onMouseMove(e));
                window.addEventListener('mousedown', (e) => this.onMouseDown(e));
                window.addEventListener('mouseup', (e) => this.onMouseUp(e));

                // Keyboard events
                document.addEventListener('keydown', (e) => this.onKeyDown(e));

                // IPC events
                ipcRenderer.on('selection-mode', (event, mode) => {
                    this.mode = mode;
                    this.updateInstructions();
                });

                // Prevent context menu
                this.canvas.addEventListener('contextmenu', (e) => e.preventDefault());
            }

            updateInstructions() {
                const instructions = document.getElementById('mode-instructions');
                if (this.mode === 'point') {
                    instructions.textContent = 'Point Mode: Click to select a point';
                } else {
                    instructions.textContent = 'Rectangle Mode: Click and drag to select an area';
                }
            }

            onMouseMove(e) {
                this.currentX = e.clientX;
                this.currentY = e.clientY;

                // Update coordinates display
                document.getElementById('coordinates').textContent =
                    `Mouse: (${this.currentX}, ${this.currentY})`;

                if (this.mode === 'rectangle' && this.isSelecting) {
                    this.drawSelection();
                } else {
                    this.drawCrosshairs();
                }
            }

            onMouseDown(e) {
                if (e.button !== 0) return; // Only left click
                console.log(e)
                if (this.mode === 'point') {
                    // Point mode - immediate selection
                    this.completePointSelection(e.clientX, e.clientY);
                } else {
                    // Rectangle mode - start selection
                    this.isSelecting = true;
                    this.startX = e.clientX;
                    this.startY = e.clientY;
                    this.currentX = e.clientX;
                    this.currentY = e.clientY;
                }
            }

            onMouseUp(e) {
                if (!this.isSelecting || this.mode !== 'rectangle') return;

                this.isSelecting = false;
                this.completeRectangleSelection();
            }

            onKeyDown(e) {
                if (e.key === 'Escape') {
                    this.cancel();
                } else if (e.key === 'Enter' && this.mode === 'rectangle' && this.selection) {
                    this.confirm();
                }
            }

            drawCrosshairs() {
                this.clearCanvas();

                // Draw crosshairs
                this.ctx.setLineDash([]);
                this.ctx.strokeStyle = '#00ff00';
                this.ctx.lineWidth = 1;

                // Vertical line
                this.ctx.beginPath();
                this.ctx.moveTo(this.currentX, 0);
                this.ctx.lineTo(this.currentX, this.canvas.height);
                this.ctx.stroke();

                // Horizontal line
                this.ctx.beginPath();
                this.ctx.moveTo(0, this.currentY);
                this.ctx.lineTo(this.canvas.width, this.currentY);
                this.ctx.stroke();

                // Center dot
                this.ctx.fillStyle = '#00ff00';
                this.ctx.beginPath();
                this.ctx.arc(this.currentX, this.currentY, 3, 0, 2 * Math.PI);
                this.ctx.fill();
            }

            drawSelection() {
                this.clearCanvas();

                if (this.mode === 'rectangle' && this.isSelecting) {
                    // Draw selection rectangle
                    this.ctx.setLineDash([5, 5]);
                    this.ctx.strokeStyle = '#00ff00';
                    this.ctx.lineWidth = 2;

                    const width = this.currentX - this.startX;
                    const height = this.currentY - this.startY;

                    this.ctx.strokeRect(this.startX, this.startY, width, height);

                    // Draw size info
                    this.ctx.fillStyle = '#00ff00';
                    this.ctx.font = '12px monospace';
                    this.ctx.fillText(
                        `${Math.abs(width)} Ã— ${Math.abs(height)}`,
                        this.startX + width / 2 - 30,
                        this.startY + height / 2
                    );
                }
            }

            clearCanvas() {
                // Fill with fully transparent pixels so the OS thinks it's drawn
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                this.ctx.fillStyle = 'rgba(0, 0, 0, 0.003)'; // Subtle alpha to force hit-testing
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
            }

            completePointSelection() {
                // Just notify Electron to get mouse position itself
                ipcRenderer.send('selection-complete', {});
            }

            completeRectangleSelection() {
                const width = Math.abs(this.currentX - this.startX);
                const height = Math.abs(this.currentY - this.startY);

                if (width < 5 || height < 5) {
                    // Too small, ignore
                    return;
                }

                // Send only width and height
                ipcRenderer.send('selection-complete', { width, height });
            }

            confirm() {
                if (this.selection) {
                    ipcRenderer.send('selection-complete', this.selection);
                }
            }

            cancel() {
                ipcRenderer.send('selection-cancelled');
            }
        }

        // Initialize when DOM is ready
        document.addEventListener('DOMContentLoaded', () => {
            new ScreenRegionSelector();
        });
    </script>
</body>

</html>